---------- Globals ----------

rt = 0      -- rt is the run time in fractions of a second of the program
last_rt = 0 -- the run time value for the previous frame (used to calculate dt)
dt = 0      -- dt is the delta between frames

PI = math.pi
TWO_PI = math.pi * 2

TIMEFUNCTIONS = {}

function updateTimeFunctions()
    for k,f in pairs(TIMEFUNCTIONS) do
        local status = f()
        if not status then    -- thread finished its task?
            --table.remove(TIMEFUNCTIONS, i)
            TIMEFUNCTIONS[k] = nil
        end
    end
end

-- set the value of the supplied global vairable
function setfield(f, v)
    local t = _G    -- start with the table of globals
    for w, d in string.gfind(f, "([%w_]+)(.?)") do
        if d == "." then      -- not last field?
            t[w] = t[w] or {}   -- create table if absent
            t = t[w]            -- get the table
            else                  -- last field
            t[w] = v            -- do the assignment
        end
    end
end

-- return the value of the supplied global vairable
function getfield(f)
    local v = _G    -- start with the table of globals
    for w in string.gfind(f, "[%w_]+") do
        v = v[w]
    end
    return v
end

-- linear interpolation from a start value to an end value over
-- a period of time
function ramp(varname,start,finish,duration)
    local start_time = rt
    
    local func = function ()
        if rt < (start_time + duration) then
            setfield(varname,linlin(rt,start_time,start_time+duration,start,finish))
            return true
        else
            return false
        end
    end
    
    TIMEFUNCTIONS[varname] = func
end

-- linear interpolation from the current value to an end value over
-- a period of time
function rampTo(varname,finish,duration)
    local start_time = rt
    local start = getfield(varname)
    
    local func = function ()
        if rt < (start_time + duration) then
            setfield(varname,linlin(rt,start_time,start_time+duration,start,finish))
            return true
        else
            return false
        end
    end
    
    TIMEFUNCTIONS[varname] = func
end

function map(func,table)
    local out = {}
    for _,v in pairs(table) do
        table.insert(out,func(v))
    end
    return out
end

List = {}
function List.new()
    return {first = 0, last = -1}
end

function List.pushleft (list, value)
    local first = list.first - 1
    list.first = first
    list[first] = value
end

function List.pushright(list, value)
    local last = list.last + 1
    list.last = last
    list[last] = value
end

function List.popleft(list)
    local first = list.first
    if first > list.last then error("list is empty") end
    local value = list[first]
    list[first] = nil        -- to allow garbage collection
    list.first = first + 1
    return value
end

function List.popright(list)
    local last = list.last
    if list.first > last then error("list is empty") end
    local value = list[last]
    list[last] = nil         -- to allow garbage collection
    list.last = last - 1
    return value
end

function _update(time)
    rt = time
    dt = rt - last_rt
    last_rt = rt

    updateTimeFunctions()
end

---------- OSC ----------

OSCDEFS = {}

-- pass OSC messages to every OSCdef listening for the address pattern
function receiveOscMessage(address,...)
    for name,func in pairs(OSCDEFS[address]) do
        func(...)
    end
end

-- add a function with the given name that listens to the given address
-- to the global table of OSCdefs
function OSCdef(name,address,func)
    if OSCDEFS[address] == nil then
        OSCDEFS[address] = {}
    end
    OSCDEFS[address][name] = func
end

---------- Window Control ----------

function displayWidth(i)
    i = i or 0
    return displayWidthI(i)
end

function displayHeight(i)
    i = i or 0
    return displayHeightI(i)
end

---------- Transformations ----------

-- allow for one or two value scaling
function scale(x,y,z)
    y = y or x
    z = z or y
    scaleXYZ(x,y,z)
end

function scaleX(x)
    scaleXYZ(x,1,1)
end

function scaleY(y)
    scaleXYZ(1,y,1)
end

function scaleZ(z)
    scaleXYZ(1,1,z)
end

---------- Color ----------

Color = {r=0,g=0,b=0,a=0}

-- allow for Processing style color assignment
function Color:new(...)
    local one, two, three, four = ...
    
    if type(one) == "table" then return one end
    
    local c
    if four ~= nil then c = {r=one,g=two,b=three,a=four} -- R G B A
    elseif three ~= nil then c = {r=one,g=two,b=three,a=1} -- R G B
    elseif two ~= nil then c = {r=one,g=one,b=one,a=two} -- Gray A
    else c = {r=one,g=one,b=one,a=1} -- Gray
    end
    return c
end

--[[
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 1].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
]]
function Color:hsla(h,s,l,a)
  a = a or 1
  local r, g, b

  if s == 0 then
    r, g, b = l, l, l -- achromatic
  else
    function hue2rgb(p, q, t)
      if t < 0   then t = t + 1 end
      if t > 1   then t = t - 1 end
      if t < 1/6 then return p + (q - p) * 6 * t end
      if t < 1/2 then return q end
      if t < 2/3 then return p + (q - p) * (2/3 - t) * 6 end
      return p
    end

    local q
    if l < 0.5 then q = l * (1 + s) else q = l + s - l * s end
    local p = 2 * l - q

    r = hue2rgb(p, q, h + 1/3)
    g = hue2rgb(p, q, h)
    b = hue2rgb(p, q, h - 1/3)
  end

  return Color:new(r,g,b,a)
end

-- allow for Processing style color assignment
function RGBA(func,...)
    local c = Color:new(...)
    func(c.r,c.g,c.b,c.a)
end

function background(...)
    RGBA(backgroundRGBA,...)
end

function color(...)
    RGBA(colorRGBA,...)
end

-- init the draw function
function draw() end

---------- Lua/Haskell Utilities ----------

-- get values and errors from Haskell
_HASKELLERR = {}

function catch_haskell(ret, err_msg)
    if ret == _HASKELLERR then
      -- `error` call adds a prefix to error message
      error(err_msg)
    end
    return ret
end

-- support for function overloading
function overloaded()
    local fns = {}
    local mt = {}
    
    local function oerror()
        return error("Invalid argument types to overloaded function")
    end
    
    function mt:__call(...)
        local arg = {...}
        local default = self.default
        
        local signature = {}
        for i,arg in ipairs {...} do
            signature[i] = type(arg)
        end
        
        signature = table.concat(signature, ",")
        
        return (fns[signature] or self.default)(...)
    end
    
    function mt:__index(key)
        local signature = {}
        local function __newindex(self, key, value)
            print(key, type(key), value, type(value))
            signature[#signature+1] = key
            fns[table.concat(signature, ",")] = value
            print("bind", table.concat(signature, ", "))
        end
        local function __index(self, key)
            print("I", key, type(key))
            signature[#signature+1] = key
            return setmetatable({}, { __index = __index, __newindex = __newindex })
        end
        return __index(self, key)
    end
    
    function mt:__newindex(key, value)
        fns[key] = value
    end
    
    return setmetatable({ default = oerror }, mt)
end

---------- Utility Functions ----------

function randSeed(seed)
    math.randomseed(seed)
end

-- random float
-- if no args, return random number [0 - 1]
-- if one arg, return random number [0 - one]
-- if two args, return random number [one - two]
function rand(one,two)
    if one == nil then return math.random()
    elseif two == nil then return linlin(math.random(),0,1,0,one)
    else return linlin(math.random(),0,1,one,two) end
end

-- integer version of rand()
function randI(one,two)
    if two == nil then return math.random(one)
    else return math.random(one,two) end
end

-- return a random value from an array
function choose(array)
    local n = #array
    return array[randI(n)]
end

-- SuperCollider's linear to linear remapping
function linlin(x,a,b,c,d)
    return (x - a) / (b - a) * (d - c) + c
end

-- SuperCollider's foldback distortion
function fold(input,lo,hi)
    b = hi - lo
    b2 = b+b
    c = (input - lo) % b2
    if c > b then c = b2-c end
    return c + lo
end

---------- Oscillators ----------

-- oscillator emulation TODO: make these better
-- period in seconds per cycle
-- phase is always 0-1
function SawWave(period,lo,hi,phase)
    period = period or 1
    lo = lo or 0
    hi = hi or 1
    phase = phase or 0
    return linlin( (rt + phase) % period, 0, period, lo, hi)
end

function SinWave(period,lo,hi,phase)
    period = period or 1
    lo = lo or 0
    hi = hi or 1
    phase = phase or 0
    return linlin( math.sin(linlin( (rt + phase) % period, 0, period,0,TWO_PI)), -1, 1, lo, hi)
end

function TriWave(period,lo,hi,phase)
    period = period or 1
    lo = lo or 0
    hi = hi or 1
    phase = phase or 0
    return linlin( fold( linlin( (rt + phase) % period, 0, period, 0, 2), 0, 1 ), 0, 1, lo, hi )
end

function PulseWave(period,width,lo,hi,phase)
    period = period or 1
    lo = lo or 0
    hi = hi or 1
    phase = phase or 0
    val = linlin( (rt + phase) % period, 0, period, lo, hi)
    if val >= width then return 0 else return 1 end
end

