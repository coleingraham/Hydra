-- rt is the run time in fractions of a second of the program
rt = 0
-- the run time value for the previous frame (used to calculate dt)
last_rt = 0
-- dt is the delta between frames
dt = 0

PI = 3.1415926535898
TWO_PI = 6.2831853071796

function updateTime(time)
    rt = time
    dt = rt - last_rt
    last_rt = rt
end

function scaleX(x)
    scale(x,1,1)
end

function scaleY(y)
    scale(1,y,1)
end

function scaleZ(z)
    scale(1,1,z)
end

function color(...)
    local one, two, three, four = ...
    if four ~= nil then colorRGBA(one,two,three,four) -- R G B A
    elseif three ~= nil then colorRGBA(one,two,three,1) -- R G B
    elseif two ~= nil then colorRGBA(one,one,one,two) -- Gray A
    else color_(one,one,one,1) -- Gray
    end
end

-- init the draw function
function draw() end

-- get values and errors from Haskell
_HASKELLERR = {}

function catch_haskell(ret, err_msg)
    if ret == _HASKELLERR then
      -- `error` call adds a prefix to error message
      error(err_msg)
    end
    return ret
end

-- support for function overloading
function overloaded()
    local fns = {}
    local mt = {}
    
    local function oerror()
        return error("Invalid argument types to overloaded function")
    end
    
    function mt:__call(...)
        local arg = {...}
        local default = self.default
        
        local signature = {}
        for i,arg in ipairs {...} do
            signature[i] = type(arg)
        end
        
        signature = table.concat(signature, ",")
        
        return (fns[signature] or self.default)(...)
    end
    
    function mt:__index(key)
        local signature = {}
        local function __newindex(self, key, value)
            print(key, type(key), value, type(value))
            signature[#signature+1] = key
            fns[table.concat(signature, ",")] = value
            print("bind", table.concat(signature, ", "))
        end
        local function __index(self, key)
            print("I", key, type(key))
            signature[#signature+1] = key
            return setmetatable({}, { __index = __index, __newindex = __newindex })
        end
        return __index(self, key)
    end
    
    function mt:__newindex(key, value)
        fns[key] = value
    end
    
    return setmetatable({ default = oerror }, mt)
end

-- SuperCollider's linear to linear remapping
function linlin(x,a,b,c,d)
    return (x - a) / (b - a) * (d - c) + c
end

-- SuperCollider's foldback distortion
function fold(input,lo,hi)
    b = hi - lo
    b2 = b+b
    c = (input - lo) % b2
    if c > b then c = b2-c end
    return c + lo
end

-- oscillator emulation TODO: make these better
-- frequency is in Hz
-- phase is always 0-1
function SawWave(freq,lo,hi,phase)
    freq = freq or 1
    lo = lo or 0
    hi = hi or 1
    phase = phase or 0
    period = 1/freq
    return linlin( (rt + phase) % period, 0, period, lo, hi)
end

function SinWave(freq,lo,hi,phase)
    freq = freq or 1
    lo = lo or 0
    hi = hi or 1
    phase = phase or 0
    period = 1/freq
    return linlin( (rt + phase) % period, 0, period, lo, hi)
end

function TriWave(freq,lo,hi,phase)
    freq = freq or 1
    lo = lo or 0
    hi = hi or 1
    phase = phase or 0
    period = 1/freq
    return linlin( fold( linlin( (rt + phase) % period, 0, period, 0, 2), 0, 1 ), 0, 1, lo, hi )
end

function PulseWave(freq,width,lo,hi,phase)
    freq = freq or 1
    width = width or 0.5
    lo = lo or 0
    hi = hi or 1
    phase = phase or 0
    period = 1/freq
    val = linlin( (rt + phase) % period, 0, period, lo, hi)
    if val >= width then return 0 else return 1 end
end
